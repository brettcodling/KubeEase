import 'package:flutter/material.dart';
import 'package:k8s/k8s.dart';
import '../exceptions/auth_token_expired_exception.dart';

/// Singleton service that manages automatic Kubernetes authentication token refresh
/// 
/// This service detects when authentication tokens expire (401 errors) and automatically
/// refreshes the Kubernetes client by reinitializing it with fresh credentials from kubeconfig.
/// 
/// Cloud-managed clusters (GKE, EKS, AKS) typically use short-lived tokens (1 hour) that
/// are generated by authentication plugins (gke-gcloud-auth-plugin, aws-iam-authenticator, etc.).
/// When these tokens expire, all API calls fail with 401 Unauthorized errors.
class AuthRefreshManager extends ChangeNotifier {
  static final AuthRefreshManager _instance = AuthRefreshManager._internal();
  factory AuthRefreshManager() => _instance;
  AuthRefreshManager._internal();

  /// Callback to refresh the Kubernetes client
  /// This should be set by the main screen to update its client instance
  Future<(Kubernetes, Kubeconfig)> Function()? _refreshCallback;

  /// Whether a refresh is currently in progress
  bool _isRefreshing = false;

  /// Last refresh timestamp
  DateTime? _lastRefreshTime;

  /// Register the callback to refresh the Kubernetes client
  void registerRefreshCallback(Future<(Kubernetes, Kubeconfig)> Function() callback) {
    _refreshCallback = callback;
  }

  /// Check if an error is a 401 authentication error and trigger refresh if needed
  /// Returns true if the error was handled (401 detected), false otherwise
  Future<bool> checkAndRefreshIfNeeded(Object error) async {
    // Check if this is a 401 error
    if (!AuthTokenExpiredException.isAuthTokenExpired(error)) {
      return false;
    }

    debugPrint('ðŸ”‘ Authentication token expired, refreshing credentials...');

    // Prevent multiple simultaneous refreshes
    if (_isRefreshing) {
      debugPrint('ðŸ”‘ Refresh already in progress, skipping...');
      return true;
    }

    // Prevent refreshing too frequently (minimum 5 seconds between refreshes)
    if (_lastRefreshTime != null) {
      final timeSinceLastRefresh = DateTime.now().difference(_lastRefreshTime!);
      if (timeSinceLastRefresh.inSeconds < 5) {
        debugPrint('ðŸ”‘ Refresh attempted too soon (${timeSinceLastRefresh.inSeconds}s ago), skipping...');
        return true;
      }
    }

    try {
      _isRefreshing = true;
      _lastRefreshTime = DateTime.now();

      // Call the refresh callback if registered
      if (_refreshCallback != null) {
        await _refreshCallback!();
        debugPrint('âœ… Kubernetes client refreshed successfully');
        notifyListeners();
        return true;
      } else {
        debugPrint('âš ï¸ No refresh callback registered');
        return false;
      }
    } catch (e) {
      debugPrint('âŒ Failed to refresh Kubernetes client: $e');
      return false;
    } finally {
      _isRefreshing = false;
    }
  }

  /// Get the time since last refresh
  Duration? getTimeSinceLastRefresh() {
    if (_lastRefreshTime == null) return null;
    return DateTime.now().difference(_lastRefreshTime!);
  }

  /// Check if a refresh is currently in progress
  bool get isRefreshing => _isRefreshing;

  /// DEBUG ONLY: Simulate a 401 error to test token refresh
  /// This creates a fake DioException with 401 status code
  Future<void> simulateTokenExpiration() async {
    debugPrint('ðŸ§ª DEBUG: Simulating 401 token expiration error...');

    // Create a fake 401 error
    final fakeError = Exception(
      'DioException [bad response]: This exception was thrown because the response has a status code of 401'
    );

    // Trigger the refresh mechanism
    await checkAndRefreshIfNeeded(fakeError);
  }
}

